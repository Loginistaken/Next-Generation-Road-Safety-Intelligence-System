// package.json
{
  "name": "rsis-qln",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "mobile": "react-native run-android",
    "simulate": "node simulateActors.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "geolib": "^3.3.3",
    "react": "18.2.0",
    "react-native": "0.73.0",
    "react-native-maps": "^1.3.2",
    "react-native-tts": "^4.0.0",
    "expo-av": "^13.0.0",
    "bcrypt": "^5.1.0",
    "jsonwebtoken": "^9.0.0"
  }
}
// server.js
const express = require("express");
const http = require("http");
const socketIo = require("socket.io");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const { calculateRiskTile } = require("./src/services/riskScore");
const { aggregateTileQLN } = require("./src/services/hazardTilesQLN");
const { predictTTC } = require("./src/services/ttcPredict");

const SECRET_KEY = 'RSIS_SECRET_KEY';
const app = express();
app.use(express.json());
const server = http.createServer(app);
const io = socketIo(server, { cors: { origin: "*" } });

let users = {};
let hazardTilesQLN = {};
let neighborTable = {};

// User Sign-Up
app.post('/signup', async (req, res) => {
  const { username, password, role, agreementAccepted } = req.body;
  if (!agreementAccepted) return res.status(400).json({ error: 'User agreement must be accepted' });
  const hashedPassword = await bcrypt.hash(password, 10);
  users[username] = { password: hashedPassword, role };
  const token = jwt.sign({ username, role }, SECRET_KEY);
  res.json({ token });
});

// User Login
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  const user = users[username];
  if (!user) return res.status(400).json({ error: 'User not found' });
  const match = await bcrypt.compare(password, user.password);
  if (!match) return res.status(400).json({ error: 'Invalid password' });
  const token = jwt.sign({ username, role: user.role }, SECRET_KEY);
  res.json({ token });
});

// Socket Authentication
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  if (!token) return next(new Error('Authentication error'));
  try {
    const payload = jwt.verify(token, SECRET_KEY);
    socket.user = payload;
    next();
  } catch (err) {
    next(new Error('Authentication error'));
  }
});

// Real-time Socket.IO
io.on("connection", (socket) => {
  console.log("IVU connected:", socket.id, "User:", socket.user.username);

  socket.on("updateActor", (data) => {
    const tileId = `${Math.floor(data.lat*100)}_${Math.floor(data.lon*100)}`;
    if (!hazardTilesQLN[tileId]) hazardTilesQLN[tileId] = { actors: [], riskScore: 0, incidents: [], historicalProbability: 0 };

    data.role = socket.user.role;
    const ephemeralToken = Math.random().toString(36).substring(2, 10);
    data.token = ephemeralToken;

    hazardTilesQLN[tileId].actors.push(data);
    hazardTilesQLN[tileId].riskScore = calculateRiskTile(hazardTilesQLN[tileId].actors);

    aggregateTileQLN(tileId, hazardTilesQLN[tileId]);

    if (!neighborTable[socket.id]) neighborTable[socket.id] = {};
    neighborTable[socket.id][ephemeralToken] = { role: data.role, trustScore: 1.0, lat: data.lat, lon: data.lon };
    if (Math.random() < 0.01) neighborTable[socket.id][ephemeralToken].trustScore -= 0.1;

    io.emit("hazardTileUpdateQLN", {
      tileId,
      ...hazardTilesQLN[tileId],
      predictiveRisk: hazardTilesQLN[tileId].historicalProbability
    });

    if (hazardTilesQLN[tileId].historicalProbability > 0.3) {
      socket.emit("predictiveAlert", {
        tileId,
        message: "High historical risk detected. Proceed with caution!"
      });
    }
  });

  socket.on("predictTTC", (tileId) => {
    const prediction = predictTTC(hazardTilesQLN[tileId]);
    socket.emit("ttcPrediction", { tileId, prediction });
  });
});

server.listen(3000, () => console.log("RSIS QLN Server running on port 3000"));
// src/services/riskScore.js
const ROLE_PRIORITY = { walker: 3, cyclist: 2, vehicle: 1, passenger: 2 };
const TTC_THRESHOLD = 5;

function calculateTTC(actorA, actorB) {
  const dx = actorB.lat - actorA.lat;
  const dy = actorB.lon - actorA.lon;
  const dv = actorB.speed - actorA.speed;
  if (dv === 0) return Infinity;
  return Math.sqrt(dx*dx + dy*dy) / Math.abs(dv);
}

function calculateRiskTile(actors) {
  let maxRisk = 0;
  for (let i = 0; i < actors.length; i++) {
    for (let j = i + 1; j < actors.length; j++) {
      const ttc = calculateTTC(actors[i], actors[j]);
      let risk = 0;
      if (ttc < TTC_THRESHOLD) risk = ROLE_PRIORITY[actors[i].role] + ROLE_PRIORITY[actors[j].role];
      if (risk > maxRisk) maxRisk = risk;
    }
  }
  return maxRisk;
}

module.exports = { calculateRiskTile, calculateTTC };
// src/services/ttcPredict.js
function predictTTC(tileData) {
  if (!tileData || !tileData.actors) return Infinity;
  let minTTC = Infinity;
  const actors = tileData.actors;
  for (let i = 0; i < actors.length; i++) {
    for (let j = i+1; j < actors.length; j++) {
      const dx = actors[j].lat - actors[i].lat;
      const dy = actors[j].lon - actors[i].lon;
      const dv = actors[j].speed - actors[i].speed;
      if (dv === 0) continue;
      const ttc = Math.sqrt(dx*dx + dy*dy)/Math.abs(dv);
      if (ttc < minTTC) minTTC = ttc;
    }
  }
  return minTTC;
}

module.exports = { predictTTC };
// src/services/hazardTilesQLN.js
let historicalTilesQLN = {};

function logIncident(tileId, actors, timestamp) {
  if (!historicalTilesQLN[tileId].incidents) historicalTilesQLN[tileId].incidents = [];
  historicalTilesQLN[tileId].incidents.push({ actors, timestamp });
  if (historicalTilesQLN[tileId].incidents.length > 200) historicalTilesQLN[tileId].incidents.shift();
}

function computeTileProbability(tileId) {
  const tile = historicalTilesQLN[tileId];
  if (!tile || !tile.incidents) return 0;
  const totalEvents = tile.actors.length || 1;
  const probability = tile.incidents.length / totalEvents;
  tile.historicalProbability = probability;
  return probability;
}

function aggregateTileQLN(tileId, tileData) {
  if (!historicalTilesQLN[tileId]) {
    historicalTilesQLN[tileId] = {
      actors: [],
      riskScore: 0,
      incidents: [],
      historicalProbability: 0,
    };
  }

  historicalTilesQLN[tileId].actors = tileData.actors;
  historicalTilesQLN[tileId].riskScore = tileData.riskScore;

  tileData.actors.forEach((actor, i) => {
    for (let j = i + 1; j < tileData.actors.length; j++) {
      const ttc = tileData.actors[j].ttc || Infinity;
      if (ttc < 5) logIncident(tileId, [tileData.actors[i], tileData.actors[j]], Date.now());
    }
  });

  computeTileProbability(tileId);

  return historicalTilesQLN[tileId];
}

module.exports = { aggregateTileQLN };
// src/services/TTSService.js
import { Audio } from 'expo-av';
const ROLE_PRIORITY = { walker: 3, cyclist: 2, vehicle: 1, passenger: 2 };

export async function playAudioAlert(actor, message) {
  const soundObject = new Audio.Sound();
  try {
    await soundObject.loadAsync(require('../../assets/alert.mp3'));
    await soundObject.setVolumeAsync(ROLE_PRIORITY[actor.role]/3);
    await soundObject.playAsync();
  } catch (error) { console.log(error); }
}

export function speakAlert(actor, message) {
  console.log(`[TTS-${actor.role}] ${message}`);
}
// src/components/IVUMap.js
import React from "react";
import MapView, { Polygon } from "react-native-maps";

export default function IVUMap({ hazardTiles }) {
  return (
    <MapView style={{ flex: 1 }}>
      {Object.keys(hazardTiles).map((tileId) => {
        const tile = hazardTiles[tileId];
        return (
          <Polygon
            key={tileId}
            coordinates={[
              { latitude: tile.actors[0]?.lat || 0, longitude: tile.actors[0]?.lon || 0 },
              { latitude: tile.actors[0]?.lat+0.001 || 0, longitude: tile.actors[0]?.lon || 0 },
              { latitude: tile.actors[0]?.lat+0.001 || 0, longitude: tile.actors[0]?.lon+0.001 || 0 },
              { latitude: tile.actors[0]?.lat || 0, longitude: tile.actors[0]?.lon+0.001 || 0 }
            ]}
            fillColor={`rgba(255,0,0,${tile.riskScore/5})`}
          />
        );
      })}
    </MapView>
  );
}
// src/components/ActorList.js
import React from "react";
import { FlatList, Text, View } from "react-native";

export default function ActorList({ actors }) {
  return (
    <FlatList
      data={actors}
      keyExtractor={(item, index) => index.toString()}
      renderItem={({ item }) => (
        <View>
          <Text>{`${item.role.toUpperCase()}: ${item.speed.toFixed(2)} m/s`}</Text>
        </View>
      )}
    />
  );
}
// src/App.js
import React, { useEffect, useState } from "react";
import { View } from "react-native";
import io from "socket.io-client";
import IVUMap from "./components/IVUMap";
import { speakAlert, playAudioAlert } from "./services/TTSService";

export default function App() {
  const [hazardTiles, setHazardTiles] = useState({});
  const socket = io("http://localhost:3000", { auth: { token: 'USER_JWT_TOKEN' }});

  useEffect(() => {
    socket.on("hazardTileUpdateQLN", (tile) => {
      setHazardTiles(prev => ({ ...prev, [tile.tileId]: tile }));
    });

    socket.on("predictiveAlert", (alert) => {
      console.log(`Predictive Alert for tile ${alert.tileId}: ${alert.message}`);
      speakAlert({ role: 'system' }, alert.message);
      playAudioAlert({ role: 'system' }, alert.message);
    });

    socket.on("ttcPrediction", (data) => {
      console.log(`Predicted TTC for tile ${data.tileId}: ${data.prediction}`);
    });
  }, []);

  return <View style={{ flex: 1 }}><IVUMap hazardTiles={hazardTiles} /></View>;
}
// simulateActors.js
const io = require("socket.io-client");
const roles = ["walker", "cyclist", "vehicle", "passenger"];
const socket = io("http://localhost:3000", { auth: { token: 'SIM_USER_JWT' }});

function rand(min, max) { return Math.random() * (max - min) + min; }
function generateActor(id) {
  return { id, lat: rand(40.0, 40.01), lon
// simulateActors.js
const io = require("socket.io-client");
const roles = ["walker", "cyclist", "vehicle", "passenger"];
const socket = io("http://localhost:3000", { auth: { token: 'SIM_USER_JWT' }});

function rand(min, max) { return Math.random() * (max - min) + min; }
function generateActor(id) {
  return { id, lat: rand(40.0, 40.01), lon: rand(-74.0, -73.99), speed: rand(0,5), role: roles[Math.floor(Math.random()*roles.length)] };
}

function simulateActors(numActors = 10, iterations = 50, interval = 1000) {
  let actors = Array.from({ length: numActors }, (_, i) => generateActor(i));
  let iter = 0;

  const simInterval = setInterval(() => {
    iter++;
    actors.forEach(actor => {
      actor.lat += rand(-0.0005, 0.0005);
      actor.lon += rand(-0.0005, 0.0005);
      actor.speed = Math.max(0, actor.speed + rand(-0.5, 0.5));
      socket.emit("updateActor", actor);
    });

    if (iter >= iterations) clearInterval(simInterval);
  }, interval);
}

socket.on("connect", () => { console.log("Simulation connected to RSIS QLN server."); simulateActors(15, 100, 500); });
socket.on("predictiveAlert", (alert) => { console.log(`SIMULATION ALERT: Tile ${alert.tileId} - ${alert.message}`); });
socket.on("hazardTileUpdateQLN", (tile) => { console.log(`Tile ${tile.tileId} risk: ${tile.riskScore.toFixed(2)}, predictiveProb: ${tile.historicalProbability.toFixed(2)}`); });
// src/services/persistentStore.js
const fs = require("fs");
const STORE_FILE = "./data/historicalTiles.json";

function loadStore() {
  try { return JSON.parse(fs.readFileSync(STORE_FILE)); }
  catch { return {}; }
}

function saveStore(store) {
  fs.writeFileSync(STORE_FILE, JSON.stringify(store, null, 2));
}

let store = loadStore();

function logIncident(tileId, actors, timestamp) {
  if (!store[tileId]) store[tileId] = { incidents: [] };
  store[tileId].incidents.push({ actors, timestamp });
  if (store[tileId].incidents.length > 500) store[tileId].incidents.shift();
  saveStore(store);
}

function getTileHistory(tileId) {
  return store[tileId] ? store[tileId].incidents : [];
}

module.exports = { logIncident, getTileHistory, store };
// src/services/hazardTilesQLN.js (upgrade)
const { logIncident, getTileHistory } = require("./persistentStore");

function aggregateTileQLN(tileId, tileData) {
  if (!tileData.incidents) tileData.incidents = [];

  // Detect new near-collisions
  tileData.actors.forEach((actorA, i) => {
    for (let j = i + 1; j < tileData.actors.length; j++) {
      const actorB = tileData.actors[j];
      const dx = actorB.lat - actorA.lat;
      const dy = actorB.lon - actorA.lon;
      const dv = actorB.speed - actorA.speed;
      const ttc = dv === 0 ? Infinity : Math.sqrt(dx*dx + dy*dy)/Math.abs(dv);
      if (ttc < 5) logIncident(tileId, [actorA, actorB], Date.now());
    }
  });

  // Compute predictive probability
  const history = getTileHistory(tileId);
  const densityFactor = Math.min(tileData.actors.length / 10, 1); // normalize
  const recentWeight = history.filter(h => Date.now() - h.timestamp < 60*60*1000).length / (history.length || 1);
  tileData.historicalProbability = Math.min(1, densityFactor * 0.5 + recentWeight * 0.5);

  return tileData;
}

module.exports = { aggregateTileQLN };
// simulateActors.js (unchanged except the server now stores persistent learning)
